<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言实现小根堆</title>
    <url>/C-Min-Heap/</url>
    <content><![CDATA[<p>数据结构有 <strong>堆排序</strong> ，但 <strong>堆排序</strong> 在众多排序算法中的能力并不突出，这是因为排序并不是它体现优势的方面，而只能算是它的附带能力。</p>
<p><strong>堆</strong> 的优势在于当从 <strong>堆</strong> 中弹出最小值（针对 <strong>小根堆</strong> 而言）时，或将某个数值放入 <strong>堆</strong> 中时，相比其他数据结构，它需要检索和调整内部其他数据元素的操作量最少，所以它更适合用来实现 <strong>优先队列</strong>，因为 <strong>优先队列</strong> 每次只会获取队列中优先级最高的数据元素，而不会操作中间某个数据元素，这和 <strong>小跟堆</strong> 每次只能弹出最小值而不能弹出其他值的行为一致。因此如 <strong>Dijkstra</strong> 算法面临顶点数量规模庞大的时候，内部实现换成 <strong>优先队列</strong> 能显著提升运算效率。</p>
<p>堆内部通过两个关键性操作 <em>shift up</em>（上浮）和 <em>shift down</em> （下沉）来维持堆内数据元素的有序化，下面是我用C语言实现的 <strong>小根堆</strong> 的完整代码，以供参考。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************************************</span></span><br><span class="line"><span class="comment">* Min-Heap</span></span><br><span class="line"><span class="comment">* Copyright (C) i@foxzzz.com</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* C implementation of the Min-Heap.</span></span><br><span class="line"><span class="comment">*********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS <span class="comment">/*for visual studio*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 堆结构体</span></span><br><span class="line"><span class="comment">* @data 数据元素</span></span><br><span class="line"><span class="comment">* @capacity 数组容量</span></span><br><span class="line"><span class="comment">* @len 元素数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tHeap</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>* data;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125; Heap, * pHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 创建堆结构体</span></span><br><span class="line"><span class="comment">* @param[in] capacity 指定数组容量</span></span><br><span class="line"><span class="comment">* @return 空指针失败 其他成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">pHeap <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    pHeap heap = (pHeap)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Heap));</span><br><span class="line">    assert(heap);</span><br><span class="line">    assert(capacity &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(heap, <span class="number">0</span>, <span class="keyword">sizeof</span>(Heap));</span><br><span class="line">    heap-&gt;capacity = capacity;</span><br><span class="line">    heap-&gt;data = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(heap-&gt;data[<span class="number">0</span>]) * heap-&gt;capacity);</span><br><span class="line">    assert(heap-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 销毁堆结构体</span></span><br><span class="line"><span class="comment">* @param[in] heap 需要销毁的结构体指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroyHeap</span><span class="params">(pHeap heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap-&gt;data) &#123;</span><br><span class="line">            <span class="built_in">free</span>(heap-&gt;data);</span><br><span class="line">            heap-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(heap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 元素上浮</span></span><br><span class="line"><span class="comment">* @param[in] heap 需要操作的堆结构指针</span></span><br><span class="line"><span class="comment">* @param[in] position 指定要上移的元素</span></span><br><span class="line"><span class="comment">*  - position 是元素编号，所以对应到数组元素时候需要 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(pHeap heap, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (position &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = position &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*与父元素进行比较，如果大于父元素则进行交换*/</span></span><br><span class="line">        <span class="keyword">if</span> (heap-&gt;data[parent - <span class="number">1</span>] &gt; heap-&gt;data[position - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = heap-&gt;data[parent - <span class="number">1</span>];</span><br><span class="line">            heap-&gt;data[parent - <span class="number">1</span>] = heap-&gt;data[position - <span class="number">1</span>];</span><br><span class="line">            heap-&gt;data[position - <span class="number">1</span>] = temp;</span><br><span class="line">            position = parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 元素下沉</span></span><br><span class="line"><span class="comment">* @param[in] heap 需要操作的堆结构指针</span></span><br><span class="line"><span class="comment">* @param[in] position 指定要下沉的元素</span></span><br><span class="line"><span class="comment">*  - position 是元素编号，所以对应到数组元素时候需要 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(pHeap heap, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (position &lt;&lt; <span class="number">1</span> &lt;= heap-&gt;len) &#123;</span><br><span class="line">        <span class="keyword">int</span> target = position &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*指定左右孩子中的较小者*/</span></span><br><span class="line">        <span class="keyword">if</span> (target + <span class="number">1</span> &lt;= heap-&gt;len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap-&gt;data[target] &lt; heap-&gt;data[target - <span class="number">1</span>]) &#123;</span><br><span class="line">                target += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*父节点大于较小者则交换*/</span></span><br><span class="line">        <span class="keyword">if</span> (heap-&gt;data[position - <span class="number">1</span>] &gt; heap-&gt;data[target - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = heap-&gt;data[target - <span class="number">1</span>];</span><br><span class="line">            heap-&gt;data[target - <span class="number">1</span>] = heap-&gt;data[position - <span class="number">1</span>];</span><br><span class="line">            heap-&gt;data[position - <span class="number">1</span>] = temp;</span><br><span class="line">            position = target;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 插入元素</span></span><br><span class="line"><span class="comment">* @param[in] heap 需要操作的堆结构指针</span></span><br><span class="line"><span class="comment">* @param[in] v 需要插入的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertHeap</span><span class="params">(pHeap heap, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*容量满了按1倍扩容*/</span></span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;capacity == heap-&gt;len) &#123;</span><br><span class="line">        heap-&gt;capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        heap-&gt;data = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(heap-&gt;data, heap-&gt;capacity);</span><br><span class="line">        assert(heap-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*插入到堆尾*/</span></span><br><span class="line">    heap-&gt;data[heap-&gt;len++] = v;</span><br><span class="line">    <span class="comment">/*调整堆结构，对堆尾元素进行上浮*/</span></span><br><span class="line">    shiftUp(heap, heap-&gt;len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 返回对顶元素，此操作要求堆不为空</span></span><br><span class="line"><span class="comment">* @param[in] heap 需要操作的堆结构指针</span></span><br><span class="line"><span class="comment">* @return 返回对顶元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topHeap</span><span class="params">(pHeap heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 弹出对顶元素</span></span><br><span class="line"><span class="comment">* @param[in] heap 需要操作的堆结构指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popHeap</span><span class="params">(pHeap heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*将堆尾元素放入堆顶*/</span></span><br><span class="line">        heap-&gt;data[<span class="number">0</span>] = heap-&gt;data[heap-&gt;len - <span class="number">1</span>];</span><br><span class="line">        --heap-&gt;len;</span><br><span class="line">        <span class="comment">/*调整堆结构，对新的堆顶元素进行下沉*/</span></span><br><span class="line">        shiftDown(heap, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*create heap*/</span></span><br><span class="line">    pHeap heap = createHeap(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*insert value*/</span></span><br><span class="line">    insertHeap(heap, <span class="number">3</span>);</span><br><span class="line">    insertHeap(heap, <span class="number">1</span>);</span><br><span class="line">    insertHeap(heap, <span class="number">4</span>);</span><br><span class="line">    insertHeap(heap, <span class="number">7</span>);</span><br><span class="line">    insertHeap(heap, <span class="number">6</span>);</span><br><span class="line">    insertHeap(heap, <span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*pop value &amp; print*/</span></span><br><span class="line">    <span class="keyword">while</span> (heap-&gt;len) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = topHeap(heap);</span><br><span class="line">        popHeap(heap);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*destroy heap*/</span></span><br><span class="line">    destroyHeap(heap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>QT连接MySQL遇到的坑</title>
    <url>/QT-to-MySQL/</url>
    <content><![CDATA[<p><strong>QT</strong> 连接 <strong>MySQL</strong> 的坑不少，记录自己的踩坑经历以备后查。</p>
<h2 id="驱动文件"><a href="#驱动文件" class="headerlink" title="驱动文件"></a>驱动文件</h2><p>驱动是指 <code>QSqlDatabase::drivers()</code> 输出的列表项，以下是输出项与对应驱动文件所在位置：</p>
<blockquote>
<p>Qt/Qt5.12.10/5.12.10/mingw73_64/plugins/sqldrivers/*.dll</p>
</blockquote>
<p>这里的5.12.10是我安装的 <strong>QT</strong> 版本，<strong>mingw73</strong> 是我安装的 <strong>mingw</strong> 版本，64是采用64位编译，每个人的配置会有所不同，可根据给出的模式检查对应 <strong>QT</strong> 目录是否存在以下两个dll：</p>
<blockquote>
<p>qsqlmysql.dll<br>qsqlmysqld.dll</p>
</blockquote>
<p>如果缺少，那么 <code>QSqlDatabase::drivers()</code> 输出项将不会出现 <em>‘QMYSQL’</em> ，这是造成无法连接的原因之一，这时候我们就需要自己编译这两个文件，如何编译后面再说。</p>
<h2 id="客户端动态库"><a href="#客户端动态库" class="headerlink" title="客户端动态库"></a>客户端动态库</h2><p>如果驱动文件存在，但是无法连接 <strong>MySQL</strong> ，那就是缺少 <strong>MySQL</strong> 的客户端动态库，找到 <strong>MySQL</strong> 的安装目录所对应的 <em>libmysql.dll</em> 文件：</p>
<blockquote>
<p>mysql-8.0.21-winx64/lib/libmysql.dll</p>
</blockquote>
<p>这里的8.0.21是我的 <strong>MySQL</strong> 版本，winx64是64位环境，可与之对照，将 <em>libmysql.dll</em> 复制到：</p>
<blockquote>
<p>Qt/Qt5.12.10/5.12.10/mingw73_64/bin/</p>
</blockquote>
<p>目录下，注意一点，x86的客户端动态库要放在对应的x86目录，x64的客户端动态库要放在对应的x64目录，别放错了。</p>
<p>重新编译执行对应版本的 <strong>QT</strong> 程序，如果能成功连接 <strong>MySQL</strong> ，那么问题解决，如果不行，说明 <em>驱动文件</em> 和 <em>客户端动态库</em> 版本不兼容，需要自己重新编译驱动文件（这里的原因多半是 <strong>MySQL</strong> 的客户端动态库是8.x.xx版本而QT中的驱动文件是针对 <strong>MySQL</strong> 的5.x.xx版本编译的）。如果不想亲自编译驱动文件，也有快速解决方法，就是下载低版本的 <strong>MySQL</strong>，从中找出 <em>libmysql.dll</em> 替换。需要说明一点， <strong>MySQL</strong> 客户端动态库需要与 <strong>QT</strong> 中的x86/x64对应，但是无须跟安装的 <strong>MySQL</strong> 服务端对应，换言之，x86的客户端动态库是可以连接x64的 <strong>MySQL</strong> 服务端的。</p>
<h2 id="编译驱动"><a href="#编译驱动" class="headerlink" title="编译驱动"></a>编译驱动</h2><p>这里是坑最多的地方，<strong>QT</strong> 有些版本是自带 <strong>MySQL</strong> 驱动文件的，但有些版本却又不带，原因可能是 <strong>MySQL</strong> 版本更新导致客户端动态库变化， <strong>QT</strong> 预制的编译好的版本太老无法兼容新的 <strong>MySQL</strong> 版本，所以干脆把这件事留给工程师自己做。</p>
<p>找到如下工程：</p>
<blockquote>
<p>Qt/Qt5.12.10/5.12.10/Src/qtbase/src/plugins/sqldrivers/mysql/mysql.pro</p>
</blockquote>
<p>启动 <em>Qt Creator</em>，将 <em>mysql.pro</em> 中的这行语句注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># QMAKE_USE += mysql</span><br></pre></td></tr></table></figure>

<p>加入两行新语句，注意一点，以下的 <em>C:/mysql-8.0.16-winx64/</em> 是我机器的 <em>MySQL</em> 安装路径，需要换成你自己的，另外，如果路径中含有空格，需要将路径首尾加上双引号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INCLUDEPATH += C:/mysql-8.0.16-winx64/include/</span><br><span class="line">LIBS += C:mysql-8.0.16-winx64/lib/libmysql.lib</span><br></pre></td></tr></table></figure>

<p>有人说要再加上 <em>DESTDIR</em> 去指定编译的驱动文件生成位置，这个我测试没有效果，不加的话会自动生成到QT安装目录的磁盘根目录下，比如我的 <strong>QT</strong> 安装在C盘，那么就是生成在：</p>
<blockquote>
<p>C:/plugins/sqldrivers/</p>
</blockquote>
<p>在QT中只需要执行 <strong>编译</strong> 操作而不需要执行 <strong>编译运行</strong> 操作，因为它编译的是dll，不是可执行文件，如果 <strong>编译运行</strong> 将出现找不到执行文件的错误提示。</p>
<p>编译过程中可能出现找不到 <em>qtsqldrivers-config.pri</em> 的错误提示，这时候可以找一找 </p>
<blockquote>
<p>Qt/Qt5.12.10/5.12.10/Src/qtbase/src/plugins/sqldrivers/qsqldriverbase.pri</p>
</blockquote>
<p>所在的同级目录是否有一个 <em>configure.pri</em>文件存在，如果存在，则打开 <em>qsqldriverbase.pri</em> 作以下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include($$shadowed($$PWD)/qtsqldrivers-config.pri)</span><br><span class="line">include(./configure.pri)</span><br></pre></td></tr></table></figure>

<p>也就是注释第一句，添加第二句。操作成功会在目录</p>
<blockquote>
<p>C:/plugins/sqldrivers/</p>
</blockquote>
<p>生成以下两个dll</p>
<blockquote>
<p>qsqlmysql.dll<br>qsqlmysqld.dll</p>
</blockquote>
<p>将之拷贝到以下目录即可：</p>
<blockquote>
<p><strong>Qt/Qt5.12.10/5.12.10/mingw73_64/plugins/sqldrivers/</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>QT</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中delete和delete[]的深层区别</title>
    <url>/cpp-array-delete/</url>
    <content><![CDATA[<p>今天又看到群里有人讨论 <strong>C++</strong> 中 <code>delete</code> 和 <code>delete[]</code> 的区别，表层原因大家都了解，因为教科书上说得很明白：<code>new</code> 和 <code>delete</code> 需配对使用， <code>new[]</code> 和 <code>delete[]</code> 需配对使用。</p>
<p>但若问起在什么情况下针对 <code>new[]</code> 申请的资源可以使用 <code>delete</code> 释放而不会有任何问题，能讲清楚这点的人就很少了。因为这涉及到对 <code>new</code> 、 <code>delete</code> 、 <code>new[]</code> 、 <code>delete[]</code> 内部实现机制的理解。</p>
<p>根本原因在于， <code>delete</code> 需要调用内存中一个元素的析构函数，而 <code>delete[]</code> 需要调用内存中若干个元素的析构函数，这里就牵涉出一个问题—— <code>delete[]</code> 是如何知道内存中元素的数量的？我们知道 <code>delete[]</code> 中的 <code>[]</code> 并不会传入参数，所以这个数量不会是 <code>delete[]</code> 传过来的，而是在 <code>new[]</code> 的时候保存的，只有这样才得以在 <code>delete[]</code> 的时候依据元素数量逐个调用析构函数。</p>
<p>接下来说 <code>new[]</code> 如何存储这个数量，首先它会动态申请一段内存，然后在这段内存的首地址空间中存入元素数量，在这个空间之后的内存分配给各元素，<code>new[]</code> 的返回值并不是这段动态内存空间的首地址，而是动态内存空间中存放第一个元素的内存地址。</p>
<p>以上说的是 <code>delete[]</code> 需要调用元素析构函数的情况，但是C++的哲学是 <strong>Zero-cost Abstraction</strong>，所以对于并没有显式定义析构函数的 <code>struct/class</code> 的对象元素来说，并不需要为其产生析构函数的代码，也就不需要在 <code>delete[]</code> 的时候调用元素的析构函数以增加无谓的运算开销，那么， <code>new[]</code> 也就不用存储这个元素数量。还有一种情况就是如 <code>int</code> 等基本类型作为空间元素的时候，也不存在析构函数的调用，所以跟没有显示定义析构函数的对象元素一样：在 <code>new[]</code> 时候不需要存储元素数量，在 <code>delete[]</code> 时候不需要调用析构函数。</p>
<p>综上所述， <code>new[]</code> 和 <code>delete[]</code> 的具体行为受对象元素是否存在必须调用析构函数而有所不同。</p>
<p>一图胜千言，我画了三张图来展现上面说的三种元素情况：</p>
<ul>
<li><code>int</code> 作为基本类型：</li>
</ul>
<p><img src="/cpp-array-delete/1.png" alt="int *ptr = new int[5]"></p>
<ul>
<li>定义了一个 <code>class A</code> ，但是 <code>A</code> 并没有显式定义析构函数：</li>
</ul>
<p><img src="/cpp-array-delete/2.png" alt="A *ptr = new A[5]"></p>
<ul>
<li>定义了一个 <code>class B</code>，并且 <code>B</code> 显式定义了析构函数：</li>
</ul>
<p><img src="/cpp-array-delete/3.png" alt="B *ptr = new B[5]"></p>
<p>可以看出，对于 <code>int *ptr = new int[5]</code> 和 <code>A *ptr = new A[5]</code> ，因为不涉及存储元素数量和对析构函数的调用，所以 <code>delete</code> 和 <code>delete[]</code> 的操作都仅仅是将传入的地址进行释放而不做其他额外事情。这种情况下，你使用 <code>delete</code> 或者 <code>delete[]</code> 都不会存在任何问题。</p>
<p>但是对于 <code>B *ptr = new B[5]</code> 却一定要使用 <code>delete[]</code> ，因为传过来的并不是真正的动态内存首地址， <code>delete[]</code> 的内部处理就会变成从传入的内存地址往前偏移获取真正的动态内存首地址，从该首地址空间获取到元素的数量，然后通过数量逐个调用元素的析构函数，完了再用得到的内存首地址释放动态内存。但若使用 <code>delete</code> 就会只调用第一个元素的析构函数，并且将第一个元素的地址作为动态内存首地址进行释放，但是释放错误的内存地址（非申请时候动态内存的首地址）将发生严重错误，如在 <strong>visual studio</strong> 中会直接触发程序异常并崩溃。</p>
<p>接下来思考另一种情况，如果 <code>B *ptr = new B</code> 操作后使用 <code>delete[]</code> 释放呢？这也会产生非常严重的错误，因为它会根据这个内存地址往前偏移获取数量，但是这个数量值是个不确定的值，所以接下来发生的行为就是在指针越界访问的情况下调用了无数次析构函数，而这些内存空间中并不存在有效元素，该行为将发生程序崩溃，即便该过程程序照常执行，接下来用偏移地址释放内存也会崩溃，总之，程序执行到此已经走火入魔了。 </p>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>delete</tag>
        <tag>delete[]</tag>
      </tags>
  </entry>
  <entry>
    <title>pthread 实现线程同步功能的 Queue</title>
    <url>/queue-with-thread-synchronization/</url>
    <content><![CDATA[<p>这几天需要使用 <strong>pthread</strong> 实现了一个线程同步功能的 <strong>Queue</strong>，过程中踩了两个坑：</p>
<ul>
<li><p><strong>pthread_cond_wait()</strong> 需要放在 <strong>pthread_mutex_lock()</strong> 和 <strong>pthread_mutex_unlock()</strong> 之中，而不是之外，否则将发生死锁，这里的概念有点绕，需要理解 <strong>pthread_cond_wait()</strong> 是会释放当前的 <em>lock</em>，以便其他线程进入临界区，当其他线程 <strong>pthread_cond_signal()</strong> 的时候，<em>wait</em> 线程被唤醒，又重新获得锁；</p>
</li>
<li><p><strong>pthread_cond_wait()</strong> 唤醒后需要再次条件判断，并且条件判断形式必须是 <strong>while</strong> 而不能是 <strong>if</strong>，之所以必须这样做的原因是<strong>pthread_cond_signal()</strong> 可能唤醒多个正处于 <em>wait</em> 状态的线程（多cpu情况），所以被唤醒的线程需要再次检测是否真有数据需要处理，如不需要处理应当继续进入 <em>wait</em> 以等待下次唤醒。</p>
</li>
</ul>
<p>我将 <strong>Queue</strong> 实现成可支持一对一、一对多、多对一、多对多的线程同步机制，并写了一个简单的生产者消费者模型用以测试。完整程序如下，测试环境是 <em>ubuntu 20.04</em>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************************************</span></span><br><span class="line"><span class="comment">* Queue with thread synchronization</span></span><br><span class="line"><span class="comment">* Copyright (C) i@foxzzz.com</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Using pthread implementation.</span></span><br><span class="line"><span class="comment">* Can be used in the producer-consumer model</span></span><br><span class="line"><span class="comment">* of one-to-one, one-to-many, many-to-one,</span></span><br><span class="line"><span class="comment">* many-to-many patterns.</span></span><br><span class="line"><span class="comment">*********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief queue with thread synchronization</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>(<span class="keyword">int</span> capacity) :</span><br><span class="line">        <span class="built_in">front_</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">back_</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">size_</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">capacity_</span>(capacity),</span><br><span class="line">        <span class="built_in">cond_send_</span>(PTHREAD_COND_INITIALIZER),</span><br><span class="line">        <span class="built_in">cond_receive_</span>(PTHREAD_COND_INITIALIZER),</span><br><span class="line">        <span class="built_in">mutex_</span>(PTHREAD_MUTEX_INITIALIZER) &#123;</span><br><span class="line">        arr_ = <span class="keyword">new</span> T[capacity_];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Queue</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">    * @brief data entry queue</span></span><br><span class="line"><span class="comment">    * @param[in] data needs to be put into the queue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">full</span>()) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond_receive_, &amp;mutex_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">enqueue</span>(data);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond_send_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">    * @brief retrieve data from the queue</span></span><br><span class="line"><span class="comment">    * @param[out] data retrieved from the queue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond_send_, &amp;mutex_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dequeue</span>(data);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond_receive_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        arr_[back_] = data;</span><br><span class="line">        back_ = (back_ + <span class="number">1</span>) % capacity_;</span><br><span class="line">        ++size_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dequeue</span><span class="params">(T&amp; data)</span> </span>&#123;</span><br><span class="line">        data = arr_[front_];</span><br><span class="line">        front_ = (front_ + <span class="number">1</span>) % capacity_;</span><br><span class="line">        --size_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size_ == capacity_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size_ == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* arr_;</span><br><span class="line">    <span class="keyword">int</span> front_;</span><br><span class="line">    <span class="keyword">int</span> back_;</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line">    <span class="keyword">int</span> capacity_;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond_send_;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond_receive_;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief a demonstration of queue operations</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Make&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Demo</span>(<span class="keyword">int</span> capacity) :</span><br><span class="line">        <span class="built_in">queue_</span>(capacity) &#123;</span><br><span class="line">        <span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">    * @brief generate the data and queue it(for producer thread)</span></span><br><span class="line"><span class="comment">    * @param[in] origin The starting value of the data</span></span><br><span class="line"><span class="comment">    * @param[in] count The amount of data to be generated</span></span><br><span class="line"><span class="comment">    * @param[in] interval the time interval(ms) to enter the queue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> origin, <span class="keyword">int</span> count, <span class="keyword">int</span> interval)</span> </span>&#123;</span><br><span class="line">        Make make;</span><br><span class="line">        <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">            T data = <span class="built_in">make</span>(origin);</span><br><span class="line">            queue_.<span class="built_in">send</span>(data);</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;send&quot;</span>, data);</span><br><span class="line">            <span class="built_in">usleep</span>(interval * <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">    * @brief retrieve data from the queue(for consumer thread)</span></span><br><span class="line"><span class="comment">    * @param[in] interval the time interval(ms) to enter the queue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">int</span> interval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            T data;</span><br><span class="line">            queue_.<span class="built_in">receive</span>(data);</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;receive&quot;</span>, data);</span><br><span class="line">            <span class="built_in">usleep</span>(interval * <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;[%-4lu ms][pid %lu][%-10s] &quot;</span>, <span class="built_in">elapsedMS</span>(), <span class="built_in">pthread_self</span>(), name);</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; buffer;</span><br><span class="line">        ss &lt;&lt; data;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;start_time_, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">elapsedMS</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">current</span>;</span></span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;current, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">diffMS</span>(start_time_, current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">diffMS</span><span class="params">(<span class="keyword">const</span> timeval&amp; start, <span class="keyword">const</span> timeval&amp; end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">        <span class="keyword">long</span> useconds = end.tv_usec - start.tv_usec;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>)(((<span class="keyword">double</span>)(seconds) * <span class="number">1000</span> + (<span class="keyword">double</span>)(useconds) / <span class="number">1000.0</span>) + <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    timeval start_time_;</span><br><span class="line">    Queue&lt;T&gt; queue_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief generates integer data</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntMake</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IntMake</span>() : <span class="built_in">count_</span>(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (origin + count_++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief thread type</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    TYPE_THREAD_SEND,</span><br><span class="line">    TYPE_THREAD_RECEIVE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief thread arguments</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Args</span> &#123;</span></span><br><span class="line">    <span class="built_in">Args</span>(Demo&lt;<span class="keyword">int</span>, IntMake&gt;&amp; demo, <span class="keyword">int</span> type, <span class="keyword">int</span> interval) :</span><br><span class="line">        <span class="built_in">demo</span>(demo),</span><br><span class="line">        <span class="built_in">type</span>(type),</span><br><span class="line">        <span class="built_in">interval</span>(interval),</span><br><span class="line">        <span class="built_in">origin</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">count</span>(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Args</span>(Demo&lt;<span class="keyword">int</span>, IntMake&gt;&amp; demo, <span class="keyword">int</span> type, <span class="keyword">int</span> interval, <span class="keyword">int</span> origin, <span class="keyword">int</span> count) :</span><br><span class="line">        <span class="built_in">demo</span>(demo),</span><br><span class="line">        <span class="built_in">type</span>(type),</span><br><span class="line">        <span class="built_in">interval</span>(interval),</span><br><span class="line">        <span class="built_in">origin</span>(origin),</span><br><span class="line">        <span class="built_in">count</span>(count) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Demo&lt;<span class="keyword">int</span>, IntMake&gt;&amp; demo;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">int</span> interval;</span><br><span class="line">    <span class="keyword">int</span> origin;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief thread info</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadInfo</span> &#123;</span></span><br><span class="line">    <span class="built_in">ThreadInfo</span>(<span class="keyword">const</span> Args&amp; args) :</span><br><span class="line">        <span class="built_in">tid</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">args</span>(args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    Args args;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief producer thread function</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_func_send</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    Args* args = (Args*)arg;</span><br><span class="line">    args-&gt;demo.<span class="built_in">send</span>(args-&gt;origin, args-&gt;count, args-&gt;interval);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief consumer thread function</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_func_receive</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    Args* args = (Args*)arg;</span><br><span class="line">    args-&gt;demo.<span class="built_in">receive</span>(args-&gt;interval);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief start to work</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(std::vector&lt;ThreadInfo&gt;&amp; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : list) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (it.args.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> TYPE_THREAD_SEND:</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;it.tid, <span class="literal">nullptr</span>, thread_func_send, &amp;it.args);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TYPE_THREAD_RECEIVE:</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;it.tid, <span class="literal">nullptr</span>, thread_func_receive, &amp;it.args);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : list) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(it.tid, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Demo&lt;<span class="keyword">int</span>, IntMake&gt; <span class="title">demo</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//configuration of the threads</span></span><br><span class="line">    std::vector&lt;ThreadInfo&gt; list = &#123;</span><br><span class="line">        <span class="built_in">ThreadInfo</span>(<span class="built_in">Args</span>(demo, TYPE_THREAD_SEND, <span class="number">2</span>, <span class="number">1</span>, <span class="number">50</span>)),</span><br><span class="line">        <span class="built_in">ThreadInfo</span>(<span class="built_in">Args</span>(demo, TYPE_THREAD_RECEIVE, <span class="number">2</span>)),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">work</span>(list);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序配置了一个生产端线程，一个消费端线程，生产端和消费端效率都设置成2ms：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Demo&lt;int, IntMake&gt; demo(10);</span><br><span class="line"></span><br><span class="line">//configuration of the threads</span><br><span class="line">std::vector&lt;ThreadInfo&gt; list = &#123;</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 2, 1, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_RECEIVE, 2)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从程序打印输出结果看，生产端和消费端类似于回合制：<br><img src="/queue-with-thread-synchronization/1.png" alt="One to One"></p>
<p>修改配置，降低消费端效率，由原来的2ms修改为20ms：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Demo&lt;int, IntMake&gt; demo(10);</span><br><span class="line"></span><br><span class="line">//configuration of the threads</span><br><span class="line">std::vector&lt;ThreadInfo&gt; list = &#123;</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 2, 1, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_RECEIVE, 20)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从程序打印输出结果看，当队列满后（队列容量设置为10），生产端需要等待消费端从队列中拿走数据后方可再生产：<br><img src="/queue-with-thread-synchronization/2.png" alt="One to One"></p>
<p>修改配置，降低生产端效率，由原来的2ms修改为20ms：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Demo&lt;int, IntMake&gt; demo(10);</span><br><span class="line"></span><br><span class="line">//configuration of the threads</span><br><span class="line">std::vector&lt;ThreadInfo&gt; list = &#123;</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 20, 1, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_RECEIVE, 2)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从程序打印输出结果看，生产端和消费端又类似于回合制，这是因为消费端效率高，它得等到生产端生产：<br><img src="/queue-with-thread-synchronization/3.png" alt="One to One"></p>
<p>修改配置，生产端数量增加到3，消费端数量不变，生产端效率是20ms，消费端效率是2ms：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Demo&lt;int, IntMake&gt; demo(10);</span><br><span class="line"></span><br><span class="line">//configuration of the threads</span><br><span class="line">std::vector&lt;ThreadInfo&gt; list = &#123;</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 20, 1, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 20, 51, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 20, 101, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_RECEIVE, 2)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从程序打印输出结果看，消费端效率还是远高于生产端，即便生产端有3个，但无法填满队列：<br><img src="/queue-with-thread-synchronization/4.png" alt="Many to One"></p>
<p>修改配置，生产端数量依然是3，消费端数量变为2，生产端效率是10ms，消费端效率是2ms：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Demo&lt;int, IntMake&gt; demo(10);</span><br><span class="line"></span><br><span class="line">//configuration of the threads</span><br><span class="line">std::vector&lt;ThreadInfo&gt; list = &#123;</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 10, 1, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 10, 51, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 10, 101, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_RECEIVE, 2)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_RECEIVE, 2)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>程序打印输出呈现多对多模式：<br><img src="/queue-with-thread-synchronization/5.png" alt="Many to One"></p>
<p>以上是几个示例的演示，配置比较简单，可按自己意思设计（创建生产端另外的两个参数一个是起始数值，一个是生产数量）。</p>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>linux</tag>
        <tag>pthread</tag>
        <tag>queue</tag>
        <tag>synchronization</tag>
      </tags>
  </entry>
  <entry>
    <title>vs2019下的linux环境开发</title>
    <url>/vs2019-for-linux/</url>
    <content><![CDATA[<p>对习惯了 <em>windows</em> 的我来说，<em>vs2019</em> 有个绝妙的功能就是可以进行 <em>linux</em> 环境下的 <em>c/c++</em> 开发，而在此之前我只能是在 <em>windows</em> 上编辑代码，然后通过 <em>github</em> 同步到 <em>ubuntu</em> 上进行编译，整个过程需要来来回回折腾，所以 <em>vs2019</em> 的这项功能极大提高了我的生产力。</p>
<p>以下记录一些使用过程中遇到的问题和解决方法。</p>
<h2 id="linux头文件同步到本地"><a href="#linux头文件同步到本地" class="headerlink" title="linux头文件同步到本地"></a>linux头文件同步到本地</h2><p><em>unistd.h</em> 等头文件是unix/linux环境特有，windows上并不存在，所以在编写代码的时候用不了 <em>vs</em> 的智能感知，而且提示出错的红色波浪线让人看着很不舒服，解决办法就是将这类头文件从远程的 <em>linux</em> 机器同步过来，做法如下：</p>
<ul>
<li>从菜单栏中选择 <strong>Debug-&gt;Options…</strong></li>
</ul>
<p><img src="/vs2019-for-linux/1.png" alt="Debug-&gt;Options..."></p>
<ul>
<li><p>进入 <strong>Cross Platform-&gt;Connection Manager-&gt;Remote Headers IntelliSense Manager</strong>，从服务器列表勾选远程的 <em>linux</em> 服务器（因为我的 <em>linux</em> 放在本机的虚拟机中，所以是127.0.0.1）<br><img src="/vs2019-for-linux/2.png" alt="Cross Platform-&gt;Connection Manager-&gt;Remote Headers IntelliSense Manager"></p>
</li>
<li><p>可以看到智能感知起作用了<br><img src="/vs2019-for-linux/3.png" alt="Linux IntelliSense"></p>
</li>
</ul>
<h2 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h2><p><em>pthrad</em> 是外部库，如工程中用到，需要在编译的时候手动加上 <em>-lpthread</em> 选项，否则会导致编译出错。但vs2019中没找到添加编译选项的设置，后来发现只要添加库依赖项就行，做法如下：</p>
<ul>
<li>从菜单栏中选择 <em>Project-&gt;xxx Properties</em></li>
</ul>
<p><img src="/vs2019-for-linux/4.png" alt="Project-&gt;xxx Properties"></p>
<ul>
<li>进入 <em>Linker-&gt;Input-&gt;Library Dependencies</em>，添加上 <em>pthread</em>，重新编译就OK了<br><img src="/vs2019-for-linux/5.png" alt="Linker-&gt;Input-&gt;Library Dependencies"></li>
</ul>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>linux</tag>
        <tag>pthread</tag>
        <tag>vs2019</tag>
      </tags>
  </entry>
  <entry>
    <title>收录一些有用的网站</title>
    <url>/site-collection/</url>
    <content><![CDATA[<p>平时学习会遇到一些有用的网站，将它们收录在这里。</p>
<ul>
<li><p><a href="https://csacademy.com/app/graph_editor/">图论算法演示器</a></p>
</li>
<li><p><a href="https://www.processon.com/">在线作图工具</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>网站收藏</tag>
        <tag>小工具</tag>
      </tags>
  </entry>
</search>
