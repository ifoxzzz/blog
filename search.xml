<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言实现小根堆</title>
    <url>/C-Min-Heap/</url>
    <content><![CDATA[<p>数据结构有 <strong>堆排序</strong> ，但 <strong>堆排序</strong> 在众多排序算法中的能力并不突出，这是因为排序并不体现 <strong>堆</strong> 的优势，而只能算是它附带的能力。</p>
<p><strong>堆</strong> 的优势在于当从 <strong>堆</strong> 中弹出最小值（针对 <strong>小根堆</strong> 而言）时，或将某个数值放入 <strong>堆</strong> 中时，相比其他数据结构，它需要检索和调整其他数据元素的操作最少，效率最优，所以它更适合用来实现 <strong>优先队列</strong>，因为 <strong>优先队列</strong> 每次只会获取队列中优先级最高的数据元素，而不会操作其他数据元素，这和 <strong>小跟堆</strong> 每次只能弹出最小值而不能弹出其他值的行为一致。因此如 <strong>Dijkstra</strong> 算法在面临规模上万的顶点个数的时候，其内部权值检索环节采用 <strong>优先队列</strong> 实现的话能显著提升算法效率。除 <strong>Dijkstra</strong> 算法外，还有像 <strong>Huffman</strong> 树的构建过程中，需要频繁从当前森林中获取根节点权值最小的树，直到森林中只剩一棵树为止，这个过程若采用 <strong>优先队列</strong> 也能显著改善性能，总之， <strong>优先队列</strong> 在各类算法中的应用非常广泛。</p>
<p>堆通过两个关键性操作 <em>shift up</em>（上浮）和 <em>shift down</em> （下沉）维护堆内数据，<em>shift up</em> 用于往堆中插入新的数据元素，<em>shift down</em> 用于从堆中弹出数据元素。</p>
<p>以下是我用C语言实现的 <strong>小根堆</strong> 的完整代码，以供参考。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************************************</span></span><br><span class="line"><span class="comment">* Min-Heap</span></span><br><span class="line"><span class="comment">* Copyright (C) i@foxzzz.com</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* C implementation of the Min-Heap.</span></span><br><span class="line"><span class="comment">*********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS <span class="comment">/*for visual studio*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 堆结构体</span></span><br><span class="line"><span class="comment">* @data 数据元素</span></span><br><span class="line"><span class="comment">* @capacity 数组容量</span></span><br><span class="line"><span class="comment">* @len 元素数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tHeap</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>* data;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125; Heap, * pHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 创建堆结构体</span></span><br><span class="line"><span class="comment">* @param[in] capacity 指定数组容量</span></span><br><span class="line"><span class="comment">* @return 空指针失败 其他成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">pHeap <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    pHeap heap = (pHeap)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Heap));</span><br><span class="line">    assert(heap);</span><br><span class="line">    assert(capacity &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(heap, <span class="number">0</span>, <span class="keyword">sizeof</span>(Heap));</span><br><span class="line">    heap-&gt;capacity = capacity;</span><br><span class="line">    heap-&gt;data = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(heap-&gt;data[<span class="number">0</span>]) * heap-&gt;capacity);</span><br><span class="line">    assert(heap-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 销毁堆结构体</span></span><br><span class="line"><span class="comment">* @param[in] heap 需要销毁的结构体指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroyHeap</span><span class="params">(pHeap heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap-&gt;data) &#123;</span><br><span class="line">            <span class="built_in">free</span>(heap-&gt;data);</span><br><span class="line">            heap-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(heap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 元素上浮</span></span><br><span class="line"><span class="comment">* @param[in] heap 需要操作的堆结构指针</span></span><br><span class="line"><span class="comment">* @param[in] position 指定要上移的元素</span></span><br><span class="line"><span class="comment">*  - position 是元素编号，所以对应到数组元素时候需要 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(pHeap heap, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (position &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = position &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*与父元素进行比较，如果大于父元素则进行交换*/</span></span><br><span class="line">        <span class="keyword">if</span> (heap-&gt;data[parent - <span class="number">1</span>] &gt; heap-&gt;data[position - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = heap-&gt;data[parent - <span class="number">1</span>];</span><br><span class="line">            heap-&gt;data[parent - <span class="number">1</span>] = heap-&gt;data[position - <span class="number">1</span>];</span><br><span class="line">            heap-&gt;data[position - <span class="number">1</span>] = temp;</span><br><span class="line">            position = parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 元素下沉</span></span><br><span class="line"><span class="comment">* @param[in] heap 需要操作的堆结构指针</span></span><br><span class="line"><span class="comment">* @param[in] position 指定要下沉的元素</span></span><br><span class="line"><span class="comment">*  - position 是元素编号，所以对应到数组元素时候需要 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(pHeap heap, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (position &lt;&lt; <span class="number">1</span> &lt;= heap-&gt;len) &#123;</span><br><span class="line">        <span class="keyword">int</span> target = position &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*指定左右孩子中的较小者*/</span></span><br><span class="line">        <span class="keyword">if</span> (target + <span class="number">1</span> &lt;= heap-&gt;len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap-&gt;data[target] &lt; heap-&gt;data[target - <span class="number">1</span>]) &#123;</span><br><span class="line">                target += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*父节点大于较小者则交换*/</span></span><br><span class="line">        <span class="keyword">if</span> (heap-&gt;data[position - <span class="number">1</span>] &gt; heap-&gt;data[target - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = heap-&gt;data[target - <span class="number">1</span>];</span><br><span class="line">            heap-&gt;data[target - <span class="number">1</span>] = heap-&gt;data[position - <span class="number">1</span>];</span><br><span class="line">            heap-&gt;data[position - <span class="number">1</span>] = temp;</span><br><span class="line">            position = target;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 插入元素</span></span><br><span class="line"><span class="comment">* @param[in] heap 需要操作的堆结构指针</span></span><br><span class="line"><span class="comment">* @param[in] v 需要插入的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertHeap</span><span class="params">(pHeap heap, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*容量满了按1倍扩容*/</span></span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;capacity == heap-&gt;len) &#123;</span><br><span class="line">        heap-&gt;capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        heap-&gt;data = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(heap-&gt;data, heap-&gt;capacity);</span><br><span class="line">        assert(heap-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*插入到堆尾*/</span></span><br><span class="line">    heap-&gt;data[heap-&gt;len++] = v;</span><br><span class="line">    <span class="comment">/*调整堆结构，对堆尾元素进行上浮*/</span></span><br><span class="line">    shiftUp(heap, heap-&gt;len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 返回对顶元素，此操作要求堆不为空</span></span><br><span class="line"><span class="comment">* @param[in] heap 需要操作的堆结构指针</span></span><br><span class="line"><span class="comment">* @return 返回对顶元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topHeap</span><span class="params">(pHeap heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief 弹出对顶元素</span></span><br><span class="line"><span class="comment">* @param[in] heap 需要操作的堆结构指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popHeap</span><span class="params">(pHeap heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*将堆尾元素放入堆顶*/</span></span><br><span class="line">        heap-&gt;data[<span class="number">0</span>] = heap-&gt;data[heap-&gt;len - <span class="number">1</span>];</span><br><span class="line">        --heap-&gt;len;</span><br><span class="line">        <span class="comment">/*调整堆结构，对新的堆顶元素进行下沉*/</span></span><br><span class="line">        shiftDown(heap, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*create heap*/</span></span><br><span class="line">    pHeap heap = createHeap(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*insert value*/</span></span><br><span class="line">    insertHeap(heap, <span class="number">3</span>);</span><br><span class="line">    insertHeap(heap, <span class="number">1</span>);</span><br><span class="line">    insertHeap(heap, <span class="number">4</span>);</span><br><span class="line">    insertHeap(heap, <span class="number">7</span>);</span><br><span class="line">    insertHeap(heap, <span class="number">6</span>);</span><br><span class="line">    insertHeap(heap, <span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*pop value &amp; print*/</span></span><br><span class="line">    <span class="keyword">while</span> (heap-&gt;len) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = topHeap(heap);</span><br><span class="line">        popHeap(heap);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*destroy heap*/</span></span><br><span class="line">    destroyHeap(heap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>QT连接MySQL遇到的坑</title>
    <url>/QT-to-MySQL/</url>
    <content><![CDATA[<p><strong>QT</strong> 连接 <strong>MySQL</strong> 的坑不少，记录自己的踩坑经历以备后查。</p>
<h2 id="驱动文件"><a href="#驱动文件" class="headerlink" title="驱动文件"></a>驱动文件</h2><p>驱动是指 <code>QSqlDatabase::drivers()</code> 输出的列表项，以下是输出项与对应驱动文件所在位置：</p>
<blockquote>
<p>Qt/Qt5.12.10/5.12.10/mingw73_64/plugins/sqldrivers/*.dll</p>
</blockquote>
<p>这里的5.12.10是我安装的 <strong>QT</strong> 版本，<strong>mingw73</strong> 是我安装的 <strong>mingw</strong> 版本，64是采用64位编译，每个人的配置会有所不同，可根据给出的模式检查对应 <strong>QT</strong> 目录是否存在以下两个dll：</p>
<blockquote>
<p>qsqlmysql.dll<br>qsqlmysqld.dll</p>
</blockquote>
<p>如果缺少，那么 <code>QSqlDatabase::drivers()</code> 输出项将不会出现 <em>‘QMYSQL’</em> ，这是造成无法连接的原因之一，这时候我们就需要自己编译这两个文件，如何编译后面再说。</p>
<h2 id="客户端动态库"><a href="#客户端动态库" class="headerlink" title="客户端动态库"></a>客户端动态库</h2><p>如果驱动文件存在，但是无法连接 <strong>MySQL</strong> ，那就是缺少 <strong>MySQL</strong> 的客户端动态库，找到 <strong>MySQL</strong> 的安装目录所对应的 <em>libmysql.dll</em> 文件：</p>
<blockquote>
<p>mysql-8.0.21-winx64/lib/libmysql.dll</p>
</blockquote>
<p>这里的8.0.21是我的 <strong>MySQL</strong> 版本，winx64是64位环境，可与之对照，将 <em>libmysql.dll</em> 复制到：</p>
<blockquote>
<p>Qt/Qt5.12.10/5.12.10/mingw73_64/bin/</p>
</blockquote>
<p>目录下，注意一点，x86的客户端动态库要放在对应的x86目录，x64的客户端动态库要放在对应的x64目录，别放错了。</p>
<p>重新编译执行对应版本的 <strong>QT</strong> 程序，如果能成功连接 <strong>MySQL</strong> ，那么问题解决，如果不行，说明 <em>驱动文件</em> 和 <em>客户端动态库</em> 版本不兼容，需要自己重新编译驱动文件（这里的原因多半是 <strong>MySQL</strong> 的客户端动态库是8.x.xx版本而QT中的驱动文件是针对 <strong>MySQL</strong> 的5.x.xx版本编译的）。如果不想亲自编译驱动文件，也有快速解决方法，就是下载低版本的 <strong>MySQL</strong>，从中找出 <em>libmysql.dll</em> 替换。需要说明一点， <strong>MySQL</strong> 客户端动态库需要与 <strong>QT</strong> 中的x86/x64对应，但是无须跟安装的 <strong>MySQL</strong> 服务端对应，换言之，x86的客户端动态库是可以连接x64的 <strong>MySQL</strong> 服务端的。</p>
<h2 id="编译驱动"><a href="#编译驱动" class="headerlink" title="编译驱动"></a>编译驱动</h2><p>这里是坑最多的地方，<strong>QT</strong> 有些版本是自带 <strong>MySQL</strong> 驱动文件的，但有些版本却又不带，原因可能是 <strong>MySQL</strong> 版本更新导致客户端动态库变化， <strong>QT</strong> 预制的编译好的版本太老无法兼容新的 <strong>MySQL</strong> 版本，所以干脆把这件事留给工程师自己做。</p>
<p>找到如下工程：</p>
<blockquote>
<p>Qt/Qt5.12.10/5.12.10/Src/qtbase/src/plugins/sqldrivers/mysql/mysql.pro</p>
</blockquote>
<p>启动 <em>Qt Creator</em>，将 <em>mysql.pro</em> 中的这行语句注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># QMAKE_USE += mysql</span><br></pre></td></tr></table></figure>

<p>加入两行新语句，注意一点，以下的 <em>C:/mysql-8.0.16-winx64/</em> 是我机器的 <em>MySQL</em> 安装路径，需要换成你自己的，另外，如果路径中含有空格，需要将路径首尾加上双引号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INCLUDEPATH += C:/mysql-8.0.16-winx64/include/</span><br><span class="line">LIBS += C:mysql-8.0.16-winx64/lib/libmysql.lib</span><br></pre></td></tr></table></figure>

<p>有人说要再加上 <em>DESTDIR</em> 去指定编译的驱动文件生成位置，这个我测试没有效果，不加的话会自动生成到QT安装目录的磁盘根目录下，比如我的 <strong>QT</strong> 安装在C盘，那么就是生成在：</p>
<blockquote>
<p>C:/plugins/sqldrivers/</p>
</blockquote>
<p>在QT中只需要执行 <strong>编译</strong> 操作而不需要执行 <strong>编译运行</strong> 操作，因为它编译的是dll，不是可执行文件，如果 <strong>编译运行</strong> 将出现找不到执行文件的错误提示。</p>
<p>编译过程中可能出现找不到 <em>qtsqldrivers-config.pri</em> 的错误提示，这时候可以找一找 </p>
<blockquote>
<p>Qt/Qt5.12.10/5.12.10/Src/qtbase/src/plugins/sqldrivers/qsqldriverbase.pri</p>
</blockquote>
<p>所在的同级目录是否有一个 <em>configure.pri</em>文件存在，如果存在，则打开 <em>qsqldriverbase.pri</em> 作以下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include($$shadowed($$PWD)/qtsqldrivers-config.pri)</span><br><span class="line">include(./configure.pri)</span><br></pre></td></tr></table></figure>

<p>也就是注释第一句，添加第二句。操作成功会在目录</p>
<blockquote>
<p>C:/plugins/sqldrivers/</p>
</blockquote>
<p>生成以下两个dll</p>
<blockquote>
<p>qsqlmysql.dll<br>qsqlmysqld.dll</p>
</blockquote>
<p>将之拷贝到以下目录即可：</p>
<blockquote>
<p><strong>Qt/Qt5.12.10/5.12.10/mingw73_64/plugins/sqldrivers/</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>QT</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中delete和delete[]的深层区别</title>
    <url>/cpp-array-delete/</url>
    <content><![CDATA[<p>今天又看到群里有人讨论 <strong>C++</strong> 中 <code>delete</code> 和 <code>delete[]</code> 的区别，表层原因大家都了解，因为教科书上说得很明白：<code>new</code> 和 <code>delete</code> 需配对使用， <code>new[]</code> 和 <code>delete[]</code> 需配对使用。</p>
<p>但若问起在什么情况下针对 <code>new[]</code> 申请的资源可以使用 <code>delete</code> 释放而不会有任何问题，能讲清楚这点的人就很少了。因为这涉及到对 <code>new</code> 、 <code>delete</code> 、 <code>new[]</code> 、 <code>delete[]</code> 内部实现机制的理解。</p>
<p>根本原因在于， <code>delete</code> 需要调用内存中一个元素的析构函数，而 <code>delete[]</code> 需要调用内存中若干个元素的析构函数，这里就牵涉出一个问题—— <code>delete[]</code> 是如何知道内存中元素的数量的？我们知道 <code>delete[]</code> 中的 <code>[]</code> 并不会传入参数，所以这个数量不会是 <code>delete[]</code> 传过来的，而是在 <code>new[]</code> 的时候保存的，只有这样才得以在 <code>delete[]</code> 的时候依据元素数量逐个调用析构函数。</p>
<p>接下来说 <code>new[]</code> 如何存储这个数量，首先它会动态申请一段内存，然后在这段内存的首地址空间中存入元素数量，在这个空间之后的内存分配给各元素，<code>new[]</code> 的返回值并不是这段动态内存空间的首地址，而是动态内存空间中存放第一个元素的内存地址。</p>
<p>以上说的是 <code>delete[]</code> 需要调用元素析构函数的情况，但是C++的哲学是 <strong>Zero-cost Abstraction</strong>，所以对于并没有显式定义析构函数的 <code>struct/class</code> 的对象元素来说，并不需要为其产生析构函数的代码，也就不需要在 <code>delete[]</code> 的时候调用元素的析构函数以增加无谓的运算开销，那么， <code>new[]</code> 也就不用存储这个元素数量。还有一种情况就是如 <code>int</code> 等基本类型作为空间元素的时候，也不存在析构函数的调用，所以跟没有显示定义析构函数的对象元素一样：在 <code>new[]</code> 时候不需要存储元素数量，在 <code>delete[]</code> 时候不需要调用析构函数。</p>
<p>综上所述， <code>new[]</code> 和 <code>delete[]</code> 的具体行为受对象元素是否存在必须调用析构函数而有所不同。</p>
<p>一图胜千言，我画了三张图来展现上面说的三种元素情况：</p>
<ul>
<li><code>int</code> 作为基本类型：</li>
</ul>
<p><img src="/cpp-array-delete/1.png" alt="int *ptr = new int[5]"></p>
<ul>
<li>定义了一个 <code>class A</code> ，但是 <code>A</code> 并没有显式定义析构函数：</li>
</ul>
<p><img src="/cpp-array-delete/2.png" alt="A *ptr = new A[5]"></p>
<ul>
<li>定义了一个 <code>class B</code>，并且 <code>B</code> 显式定义了析构函数：</li>
</ul>
<p><img src="/cpp-array-delete/3.png" alt="B *ptr = new B[5]"></p>
<p>可以看出，对于 <code>int *ptr = new int[5]</code> 和 <code>A *ptr = new A[5]</code> ，因为不涉及存储元素数量和对析构函数的调用，所以 <code>delete</code> 和 <code>delete[]</code> 的操作都仅仅是将传入的地址进行释放而不做其他额外事情。这种情况下，你使用 <code>delete</code> 或者 <code>delete[]</code> 都不会存在任何问题。</p>
<p>但是对于 <code>B *ptr = new B[5]</code> 却一定要使用 <code>delete[]</code> ，因为传过来的并不是真正的动态内存首地址， <code>delete[]</code> 的内部处理就会变成从传入的内存地址往前偏移获取真正的动态内存首地址，从该首地址空间获取到元素的数量，然后通过数量逐个调用元素的析构函数，完了再用得到的内存首地址释放动态内存。但若使用 <code>delete</code> 就会只调用第一个元素的析构函数，并且将第一个元素的地址作为动态内存首地址进行释放，但是释放错误的内存地址（非申请时候动态内存的首地址）将发生严重错误，如在 <strong>visual studio</strong> 中会直接触发程序异常并崩溃。</p>
<p>接下来思考另一种情况，如果 <code>B *ptr = new B</code> 操作后使用 <code>delete[]</code> 释放呢？这也会产生非常严重的错误，因为它会根据这个内存地址往前偏移获取数量，但是这个数量值是个不确定的值，所以接下来发生的行为就是在指针越界访问的情况下调用了无数次析构函数，而这些内存空间中并不存在有效元素，该行为将发生程序崩溃，即便该过程程序照常执行，接下来用偏移地址释放内存也会崩溃，总之，程序执行到此已经走火入魔了。 </p>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>delete</tag>
        <tag>delete[]</tag>
      </tags>
  </entry>
  <entry>
    <title>pthread 实现线程同步功能的 Queue</title>
    <url>/queue-with-thread-synchronization/</url>
    <content><![CDATA[<p>这几天需要使用 <strong>pthread</strong> 实现了一个线程同步功能的 <strong>Queue</strong>，过程中踩了两个坑：</p>
<ul>
<li><p><strong>pthread_cond_wait()</strong> 需要放在 <strong>pthread_mutex_lock()</strong> 和 <strong>pthread_mutex_unlock()</strong> 之中，而不是之外，否则将发生死锁，这里的概念有点绕，需要理解 <strong>pthread_cond_wait()</strong> 是会释放当前的 <em>lock</em>，以便其他线程进入临界区，当其他线程 <strong>pthread_cond_signal()</strong> 的时候，<em>wait</em> 线程被唤醒，又重新获得锁；</p>
</li>
<li><p><strong>pthread_cond_wait()</strong> 唤醒后需要再次条件判断，并且条件判断形式必须是 <strong>while</strong> 而不能是 <strong>if</strong>，之所以必须这样做的原因是<strong>pthread_cond_signal()</strong> 可能唤醒多个正处于 <em>wait</em> 状态的线程（多cpu情况），所以被唤醒的线程需要再次检测是否真有数据需要处理，如不需要处理应当继续进入 <em>wait</em> 以等待下次唤醒。</p>
</li>
</ul>
<p>我将 <strong>Queue</strong> 实现成可支持一对一、一对多、多对一、多对多的线程同步机制，并写了一个简单的生产者消费者模型用以测试。完整程序如下，测试环境是 <em>ubuntu 20.04</em>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************************************</span></span><br><span class="line"><span class="comment">* Queue with thread synchronization</span></span><br><span class="line"><span class="comment">* Copyright (C) i@foxzzz.com</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Using pthread implementation.</span></span><br><span class="line"><span class="comment">* Can be used in the producer-consumer model</span></span><br><span class="line"><span class="comment">* of one-to-one, one-to-many, many-to-one,</span></span><br><span class="line"><span class="comment">* many-to-many patterns.</span></span><br><span class="line"><span class="comment">*********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief queue with thread synchronization</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>(<span class="keyword">int</span> capacity) :</span><br><span class="line">        <span class="built_in">front_</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">back_</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">size_</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">capacity_</span>(capacity),</span><br><span class="line">        <span class="built_in">cond_send_</span>(PTHREAD_COND_INITIALIZER),</span><br><span class="line">        <span class="built_in">cond_receive_</span>(PTHREAD_COND_INITIALIZER),</span><br><span class="line">        <span class="built_in">mutex_</span>(PTHREAD_MUTEX_INITIALIZER) &#123;</span><br><span class="line">        arr_ = <span class="keyword">new</span> T[capacity_];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Queue</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">    * @brief data entry queue</span></span><br><span class="line"><span class="comment">    * @param[in] data needs to be put into the queue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">full</span>()) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond_receive_, &amp;mutex_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">enqueue</span>(data);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond_send_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">    * @brief retrieve data from the queue</span></span><br><span class="line"><span class="comment">    * @param[out] data retrieved from the queue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond_send_, &amp;mutex_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dequeue</span>(data);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond_receive_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        arr_[back_] = data;</span><br><span class="line">        back_ = (back_ + <span class="number">1</span>) % capacity_;</span><br><span class="line">        ++size_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dequeue</span><span class="params">(T&amp; data)</span> </span>&#123;</span><br><span class="line">        data = arr_[front_];</span><br><span class="line">        front_ = (front_ + <span class="number">1</span>) % capacity_;</span><br><span class="line">        --size_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size_ == capacity_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size_ == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* arr_;</span><br><span class="line">    <span class="keyword">int</span> front_;</span><br><span class="line">    <span class="keyword">int</span> back_;</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line">    <span class="keyword">int</span> capacity_;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond_send_;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond_receive_;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief a demonstration of queue operations</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Make&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Demo</span>(<span class="keyword">int</span> capacity) :</span><br><span class="line">        <span class="built_in">queue_</span>(capacity) &#123;</span><br><span class="line">        <span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">    * @brief generate the data and queue it(for producer thread)</span></span><br><span class="line"><span class="comment">    * @param[in] origin The starting value of the data</span></span><br><span class="line"><span class="comment">    * @param[in] count The amount of data to be generated</span></span><br><span class="line"><span class="comment">    * @param[in] interval the time interval(ms) to enter the queue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> origin, <span class="keyword">int</span> count, <span class="keyword">int</span> interval)</span> </span>&#123;</span><br><span class="line">        Make make;</span><br><span class="line">        <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">            T data = <span class="built_in">make</span>(origin);</span><br><span class="line">            queue_.<span class="built_in">send</span>(data);</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;send&quot;</span>, data);</span><br><span class="line">            <span class="built_in">usleep</span>(interval * <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">    * @brief retrieve data from the queue(for consumer thread)</span></span><br><span class="line"><span class="comment">    * @param[in] interval the time interval(ms) to enter the queue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">int</span> interval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            T data;</span><br><span class="line">            queue_.<span class="built_in">receive</span>(data);</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;receive&quot;</span>, data);</span><br><span class="line">            <span class="built_in">usleep</span>(interval * <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;[%-4lu ms][pid %lu][%-10s] &quot;</span>, <span class="built_in">elapsedMS</span>(), <span class="built_in">pthread_self</span>(), name);</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; buffer;</span><br><span class="line">        ss &lt;&lt; data;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;start_time_, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">elapsedMS</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">current</span>;</span></span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;current, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">diffMS</span>(start_time_, current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">diffMS</span><span class="params">(<span class="keyword">const</span> timeval&amp; start, <span class="keyword">const</span> timeval&amp; end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">        <span class="keyword">long</span> useconds = end.tv_usec - start.tv_usec;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>)(((<span class="keyword">double</span>)(seconds) * <span class="number">1000</span> + (<span class="keyword">double</span>)(useconds) / <span class="number">1000.0</span>) + <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    timeval start_time_;</span><br><span class="line">    Queue&lt;T&gt; queue_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief generates integer data</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntMake</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IntMake</span>() : <span class="built_in">count_</span>(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (origin + count_++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief thread type</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    TYPE_THREAD_SEND,</span><br><span class="line">    TYPE_THREAD_RECEIVE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief thread arguments</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Args</span> &#123;</span></span><br><span class="line">    <span class="built_in">Args</span>(Demo&lt;<span class="keyword">int</span>, IntMake&gt;&amp; demo, <span class="keyword">int</span> type, <span class="keyword">int</span> interval) :</span><br><span class="line">        <span class="built_in">demo</span>(demo),</span><br><span class="line">        <span class="built_in">type</span>(type),</span><br><span class="line">        <span class="built_in">interval</span>(interval),</span><br><span class="line">        <span class="built_in">origin</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">count</span>(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Args</span>(Demo&lt;<span class="keyword">int</span>, IntMake&gt;&amp; demo, <span class="keyword">int</span> type, <span class="keyword">int</span> interval, <span class="keyword">int</span> origin, <span class="keyword">int</span> count) :</span><br><span class="line">        <span class="built_in">demo</span>(demo),</span><br><span class="line">        <span class="built_in">type</span>(type),</span><br><span class="line">        <span class="built_in">interval</span>(interval),</span><br><span class="line">        <span class="built_in">origin</span>(origin),</span><br><span class="line">        <span class="built_in">count</span>(count) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Demo&lt;<span class="keyword">int</span>, IntMake&gt;&amp; demo;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">int</span> interval;</span><br><span class="line">    <span class="keyword">int</span> origin;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief thread info</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadInfo</span> &#123;</span></span><br><span class="line">    <span class="built_in">ThreadInfo</span>(<span class="keyword">const</span> Args&amp; args) :</span><br><span class="line">        <span class="built_in">tid</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">args</span>(args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    Args args;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief producer thread function</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_func_send</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    Args* args = (Args*)arg;</span><br><span class="line">    args-&gt;demo.<span class="built_in">send</span>(args-&gt;origin, args-&gt;count, args-&gt;interval);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief consumer thread function</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_func_receive</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    Args* args = (Args*)arg;</span><br><span class="line">    args-&gt;demo.<span class="built_in">receive</span>(args-&gt;interval);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* @brief start to work</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(std::vector&lt;ThreadInfo&gt;&amp; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : list) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (it.args.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> TYPE_THREAD_SEND:</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;it.tid, <span class="literal">nullptr</span>, thread_func_send, &amp;it.args);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TYPE_THREAD_RECEIVE:</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;it.tid, <span class="literal">nullptr</span>, thread_func_receive, &amp;it.args);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : list) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(it.tid, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Demo&lt;<span class="keyword">int</span>, IntMake&gt; <span class="title">demo</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//configuration of the threads</span></span><br><span class="line">    std::vector&lt;ThreadInfo&gt; list = &#123;</span><br><span class="line">        <span class="built_in">ThreadInfo</span>(<span class="built_in">Args</span>(demo, TYPE_THREAD_SEND, <span class="number">2</span>, <span class="number">1</span>, <span class="number">50</span>)),</span><br><span class="line">        <span class="built_in">ThreadInfo</span>(<span class="built_in">Args</span>(demo, TYPE_THREAD_RECEIVE, <span class="number">2</span>)),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">work</span>(list);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序配置了一个生产端线程，一个消费端线程，生产端和消费端效率都设置成2ms：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Demo&lt;int, IntMake&gt; demo(10);</span><br><span class="line"></span><br><span class="line">//configuration of the threads</span><br><span class="line">std::vector&lt;ThreadInfo&gt; list = &#123;</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 2, 1, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_RECEIVE, 2)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从程序打印输出结果看，生产端和消费端类似于回合制：<br><img src="/queue-with-thread-synchronization/1.png" alt="One to One"></p>
<p>修改配置，降低消费端效率，由原来的2ms修改为20ms：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Demo&lt;int, IntMake&gt; demo(10);</span><br><span class="line"></span><br><span class="line">//configuration of the threads</span><br><span class="line">std::vector&lt;ThreadInfo&gt; list = &#123;</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 2, 1, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_RECEIVE, 20)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从程序打印输出结果看，当队列满后（队列容量设置为10），生产端需要等待消费端从队列中拿走数据后方可再生产：<br><img src="/queue-with-thread-synchronization/2.png" alt="One to One"></p>
<p>修改配置，降低生产端效率，由原来的2ms修改为20ms：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Demo&lt;int, IntMake&gt; demo(10);</span><br><span class="line"></span><br><span class="line">//configuration of the threads</span><br><span class="line">std::vector&lt;ThreadInfo&gt; list = &#123;</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 20, 1, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_RECEIVE, 2)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从程序打印输出结果看，生产端和消费端又类似于回合制，这是因为消费端效率高，它得等到生产端生产：<br><img src="/queue-with-thread-synchronization/3.png" alt="One to One"></p>
<p>修改配置，生产端数量增加到3，消费端数量不变，生产端效率是20ms，消费端效率是2ms：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Demo&lt;int, IntMake&gt; demo(10);</span><br><span class="line"></span><br><span class="line">//configuration of the threads</span><br><span class="line">std::vector&lt;ThreadInfo&gt; list = &#123;</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 20, 1, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 20, 51, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 20, 101, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_RECEIVE, 2)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从程序打印输出结果看，消费端效率还是远高于生产端，即便生产端有3个，但无法填满队列：<br><img src="/queue-with-thread-synchronization/4.png" alt="Many to One"></p>
<p>修改配置，生产端数量依然是3，消费端数量变为2，生产端效率是10ms，消费端效率是2ms：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Demo&lt;int, IntMake&gt; demo(10);</span><br><span class="line"></span><br><span class="line">//configuration of the threads</span><br><span class="line">std::vector&lt;ThreadInfo&gt; list = &#123;</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 10, 1, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 10, 51, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_SEND, 10, 101, 50)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_RECEIVE, 2)),</span><br><span class="line">    ThreadInfo(Args(demo, TYPE_THREAD_RECEIVE, 2)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>程序打印输出呈现多对多模式：<br><img src="/queue-with-thread-synchronization/5.png" alt="Many to One"></p>
<p>以上是几个示例的演示，配置比较简单，可按自己意思设计（创建生产端另外的两个参数一个是起始数值，一个是生产数量）。</p>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>linux</tag>
        <tag>pthread</tag>
        <tag>queue</tag>
        <tag>synchronization</tag>
      </tags>
  </entry>
  <entry>
    <title>收录一些有用的网站</title>
    <url>/site-collection/</url>
    <content><![CDATA[<p>平时学习会遇到一些有用的网站，将它们收录在这里。</p>
<ul>
<li><p><a href="https://csacademy.com/app/graph_editor/">图论算法演示器</a></p>
</li>
<li><p><a href="https://www.processon.com/">在线作图工具</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>网站收藏</tag>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title>vs2019下的linux环境开发</title>
    <url>/vs2019-for-linux/</url>
    <content><![CDATA[<p>对习惯了 <em>windows</em> 的我来说，<em>vs2019</em> 有个绝妙的功能就是可以进行 <em>linux</em> 环境下的 <em>c/c++</em> 开发，而在此之前我只能是在 <em>windows</em> 上编辑代码，然后通过 <em>github</em> 同步到 <em>ubuntu</em> 上进行编译，整个过程需要来来回回折腾，所以 <em>vs2019</em> 的这项功能极大提高了我的生产力。</p>
<p>以下记录一些使用过程中遇到的问题和解决方法。</p>
<h2 id="linux头文件同步到本地"><a href="#linux头文件同步到本地" class="headerlink" title="linux头文件同步到本地"></a>linux头文件同步到本地</h2><p><em>unistd.h</em> 等头文件是unix/linux环境特有，windows上并不存在，所以在编写代码的时候用不了 <em>vs</em> 的智能感知，而且提示出错的红色波浪线让人看着很不舒服，解决办法就是将这类头文件从远程的 <em>linux</em> 机器同步过来，做法如下：</p>
<ul>
<li>从菜单栏中选择 <strong>Debug-&gt;Options…</strong></li>
</ul>
<p><img src="/vs2019-for-linux/1.png" alt="Debug-&gt;Options..."></p>
<ul>
<li><p>进入 <strong>Cross Platform-&gt;Connection Manager-&gt;Remote Headers IntelliSense Manager</strong>，从服务器列表勾选远程的 <em>linux</em> 服务器（因为我的 <em>linux</em> 放在本机的虚拟机中，所以是127.0.0.1）<br><img src="/vs2019-for-linux/2.png" alt="Cross Platform-&gt;Connection Manager-&gt;Remote Headers IntelliSense Manager"></p>
</li>
<li><p>可以看到智能感知起作用了<br><img src="/vs2019-for-linux/3.png" alt="Linux IntelliSense"></p>
</li>
</ul>
<h2 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h2><p><em>pthrad</em> 是外部库，如工程中用到，需要在编译的时候手动加上 <em>-lpthread</em> 选项，否则会导致编译出错。但vs2019中没找到添加编译选项的设置，后来发现只要添加库依赖项就行，做法如下：</p>
<ul>
<li>从菜单栏中选择 <em>Project-&gt;xxx Properties</em></li>
</ul>
<p><img src="/vs2019-for-linux/4.png" alt="Project-&gt;xxx Properties"></p>
<ul>
<li>进入 <em>Linker-&gt;Input-&gt;Library Dependencies</em>，添加上 <em>pthread</em>，重新编译就OK了<br><img src="/vs2019-for-linux/5.png" alt="Linker-&gt;Input-&gt;Library Dependencies"></li>
</ul>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>linux</tag>
        <tag>pthread</tag>
        <tag>vs2019</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现Huffman的编码和解码</title>
    <url>/Huffman-Code-Demo/</url>
    <content><![CDATA[<p>说起 <code>Huffman</code> 的算法原理其实很简单，难在实现过程中对细节的控制，比如 <code>字串流</code> 转换成 <code>比特流</code> ， <code>比特流</code> 转换回 <code>字串流</code> ，这类操作极易出错；再比如要使 <code>解码</code> 过程效率更高，需要让 <code>游标指针</code> 在逐个获取 <code>比特位</code> 的过程中高效地从根节点移动到目标节点，从而获取目标节点对应解码字符；再就是针对解码所必须的 <code>字符集频率表</code> 如何设计才能最大限度减少体积。总之我的体会就是，若要亲手实现一个各方面鲁棒良好的 <code>Huffman Code Program</code> 其过程并不那么轻松。</p>
<hr>
<h3 id="输入数据测试"><a href="#输入数据测试" class="headerlink" title="输入数据测试"></a>输入数据测试</h3><p>为检测 <code>Huffman Tree</code> 的构建是否正常，我写了一个测试功能，可以输入字符以及频率来构建一颗 <code>Huffman Tree</code> ，并打印  <code>Huffman Tree</code> 的 <code>树形图</code> 和 <code>编码表</code>，下面展示的是我以数据 <code>&#123;A:1, B:2, C:3, D:4&#125;</code> 的构建效果：</p>
<ul>
<li>输入数据构建 <code>Huffman Tree</code></li>
</ul>
<p><img src="/Huffman-Code-Demo/2.png" alt="Input data to test"></p>
<ul>
<li> <code>Huffman Tree</code> 的 <code>树形图</code> 展现</li>
</ul>
<p><img src="/Huffman-Code-Demo/3.png" alt="Print Huffman Tree"></p>
<ul>
<li> <code>Huffman Tree</code> 的 <code>编码表</code> 展现</li>
</ul>
<p><img src="/Huffman-Code-Demo/4.png" alt="Print Huffman Code List"></p>
<hr>
<h3 id="文件的字符集频率表的设计"><a href="#文件的字符集频率表的设计" class="headerlink" title="文件的字符集频率表的设计"></a>文件的字符集频率表的设计</h3><p>下面说说文件的压缩和解压，文件存储不光要存储压缩数据，还需要在文件头部额外存储 <code>字符集频率表</code> ，目的是为了文件解压时，可根据 <code>字符集频率表</code> 重新构建回 <code>Huffman Tree</code> ，并在构建的 <code>Huffman Tree</code> 上将压缩数据解码成原始数据。 <code>字符集频率表</code> 应最大限度减少体积，这样才能降低文件的总体积。所以根据上述说法，文件内容将分为两部分—— <code>文件头部信息块</code> 和 <code>编码数据</code>， <code>文件头部信息块</code> 内含 <code>文件头标识</code> 和 <code>字符集频率表</code>。</p>
<p>还是拿上面的数据 <code>&#123;A:1, B:2, C:3, D:4&#125;</code> 为案例，我的 <code>文件头信息</code> 设计如下：<br><img src="/Huffman-Code-Demo/1.png" alt="File Header Info"></p>
<blockquote>
<p>文件头的两个字节是类型标识 ：<code>FX</code> ，用来标识这是一个压缩文件，通过扫描文件头标识，可知晓该文件是要进行压缩还是解压操作。<br>接下来是 <code>字符集频率表</code> ，第一个字节是表长，特别注意，它的值是 <code>0 ~ 255</code> ，表示的表长范围是 <code>1 ~ 256</code>，所以字符集 <code>&#123;A:1, B:2, C:3, D:4&#125;</code> 的表长是3而不是4。接下来每5个字节代表一个字符信息，其中1个字节存储字符编码剩下4个字节存储该字符的频率，例如A的频率是1，所以4个字节中存放的是 <code>&#123;0,0,0,1&#125;</code>，由此可见我的设计尚有压缩空间，如果我用2个 <code>比特位</code> 标识频该字符频率占用的字节数，那么4个字节的占用将压缩到1个字节，整个 <code>字符集频率表</code> 能缩小几倍。如我目前存储上述 <code>字符集频率表</code> 信息需要 <code>1+5*4=21</code> 字节，采用这种方式能压缩到 <code>1+2*4=9</code> 字节。这点留待以后再优化吧。</p>
</blockquote>
<hr>
<h3 id="文件的压缩和解压测试"><a href="#文件的压缩和解压测试" class="headerlink" title="文件的压缩和解压测试"></a>文件的压缩和解压测试</h3><p>拿源文件本身来测试压缩和解压：</p>
<ul>
<li> 读取 <code>demo.c</code> 源文件，构建 <code>Huffman Tree</code> 耗时1毫秒</li>
</ul>
<p><img src="/Huffman-Code-Demo/5.png" alt="Read File"></p>
<ul>
<li> <code>Huffman Tree</code> 的 <code>树形图</code> 展现</li>
</ul>
<p><img src="/Huffman-Code-Demo/6.png" alt="Print Huffman Tree"></p>
<ul>
<li> <code>Huffman Tree</code> 的 <code>编码表</code> 展现</li>
</ul>
<p><img src="/Huffman-Code-Demo/7.png" alt="Print Huffman Code List"></p>
<ul>
<li> 压缩程序源文件 <code>demo.c</code> 耗时9毫秒， <code>字符集频率表</code> 为 <code>803 字节</code> ，原始数据 <code>23565 字节</code>，压缩后 <code>15134 字节</code>，压缩率 <code>64.22%</code> ， 可见 <code>Huffman</code> 算法的压缩率取决于字符频次，如果频次差距越大压缩率越理想，总体来说，对二进制文件的压缩率偏低，对文本的压缩率在 <code>50%</code> 左右，其实也不算很高，所以压缩软件并不会单纯只用 <code>Huffman</code> 算法，而是多种压缩算法协同使用。</li>
</ul>
<p><img src="/Huffman-Code-Demo/8.png" alt="Encode"></p>
<ul>
<li> 解压产生的压缩文件 <code>encodefile</code> ，耗时0.89毫秒</li>
</ul>
<p><img src="/Huffman-Code-Demo/9.png" alt="Decode"></p>
<hr>
<h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><p>程序仅使用C的常用标准库函数，且编写采用 <code>C89</code> 标准，其目的是为程序拥有更广泛的适应性，以下是程序的完整代码，可供参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************************************</span></span><br><span class="line"><span class="comment">* Huffman Code Demo</span></span><br><span class="line"><span class="comment">* Copyright (C) i@foxzzz.com</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* C implementation of the Huffman Code&#x27;s</span></span><br><span class="line"><span class="comment">* encoding and decoding.</span></span><br><span class="line"><span class="comment">*********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*数据列表长度*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_SIZE 256</span></span><br><span class="line"><span class="comment">/*构建Huffman树需要产生的森林长度*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOREST_SIZE (LIST_SIZE * 2 - 1)</span></span><br><span class="line"><span class="comment">/*单个数据产生的Huffman编码文本串的最大容量*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_MAX 2048</span></span><br><span class="line"><span class="comment">/*文件路径长度*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH_MAX 1024</span></span><br><span class="line"><span class="comment">/*文件头标识*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> FILE_HEADER_FLAG[] = &#123; <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;X&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*节点标识*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    NODE_FLAG_ROOT,          <span class="comment">/*根节点*/</span></span><br><span class="line">    NODE_FLAG_LEFT,          <span class="comment">/*左孩子节点*/</span></span><br><span class="line">    NODE_FLAG_RIGHT          <span class="comment">/*右孩子节点*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*节点类型*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    NODE_TYPE_DATA,          <span class="comment">/*数据节点*/</span></span><br><span class="line">    NODE_TYPE_BLANK          <span class="comment">/*空节点*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*文件类型*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    FILE_TYPE_NULL,          <span class="comment">/*读取出错*/</span></span><br><span class="line">    FILE_TYPE_ENCODE,        <span class="comment">/*原始数据文件*/</span></span><br><span class="line">    FILE_TYPE_DECODE,        <span class="comment">/*压缩数据文件*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*字节类型*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Byte;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Huffman树节点*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> type;                <span class="comment">/*节点类型*/</span></span><br><span class="line">    <span class="keyword">int</span> data;                <span class="comment">/*节点数据*/</span></span><br><span class="line">    <span class="keyword">int</span> weight;              <span class="comment">/*节点权重*/</span></span><br><span class="line">    <span class="keyword">char</span> code[CODE_MAX];     <span class="comment">/*Huffman编码*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">tNode</span>* <span class="title">left</span>;</span>     <span class="comment">/*左孩子*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">tNode</span>* <span class="title">right</span>;</span>    <span class="comment">/*右孩子*/</span></span><br><span class="line">&#125;Node, * pNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Huffman树信息*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tHuffmanTree</span> &#123;</span></span><br><span class="line">    pNode root;              <span class="comment">/*根节点*/</span></span><br><span class="line">    <span class="keyword">int</span> total                <span class="comment">/*总字节数*/</span>;</span><br><span class="line">&#125;HuffmanTree, * pHuffmanTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*得到当前时间戳*/</span></span><br><span class="line"><span class="function">struct timeval <span class="title">startTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">stamp</span>;</span></span><br><span class="line">    gettimeofday(&amp;stamp, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> stamp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算从时间戳到当前时间的毫秒*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">endTimestamp</span><span class="params">(struct timeval start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> diff_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> start_msec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> end_msec = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">end</span>;</span></span><br><span class="line">    gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">    diff_sec = (<span class="keyword">int</span>)(end.tv_sec - start.tv_sec);</span><br><span class="line">    start_msec = (<span class="keyword">double</span>)start.tv_usec / <span class="number">1000.0</span>;</span><br><span class="line">    end_msec = (diff_sec * <span class="number">1000</span>) + ((<span class="keyword">double</span>)end.tv_usec / <span class="number">1000.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (end_msec - start_msec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建Huffman树的数据节点*/</span></span><br><span class="line"><span class="function">pNode <span class="title">createDataNode</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    pNode node = (pNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;type = NODE_TYPE_DATA;</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;weight = weight;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建Huffman树的空节点*/</span></span><br><span class="line"><span class="function">pNode <span class="title">createBlankNode</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    pNode node = (pNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;type = NODE_TYPE_BLANK;</span><br><span class="line">    node-&gt;weight = weight;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将Huffman树节点添加到森林列表*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNodeToList</span><span class="params">(pNode nodelist[], <span class="keyword">int</span> size, pNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; size; ++index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodelist[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/*从表中找到空位放入新节点*/</span></span><br><span class="line">            nodelist[index] = node;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从森林列表弹出权重最低的Huffman树节点*/</span></span><br><span class="line"><span class="function">pNode <span class="title">popMinNodeFromList</span><span class="params">(pNode nodelist[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; size; ++index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodelist[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">-1</span>) &#123;</span><br><span class="line">                min = index;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nodelist[min]-&gt;weight &gt; nodelist[index]-&gt;weight) &#123;</span><br><span class="line">                    <span class="comment">/*当发现存在更小权重节点时候更新记录*/</span></span><br><span class="line">                    min = index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (min != <span class="number">-1</span>) &#123;</span><br><span class="line">        pNode node = nodelist[min];</span><br><span class="line">        nodelist[min] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通过递归遍历方式为Huffman树中的的所有节点产生Huffman编码*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateHuffmanCode</span><span class="params">(pNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(root-&gt;left-&gt;code, root-&gt;code);</span><br><span class="line">            <span class="built_in">strcat</span>(root-&gt;left-&gt;code, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            generateHuffmanCode(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(root-&gt;right-&gt;code, root-&gt;code);</span><br><span class="line">            <span class="built_in">strcat</span>(root-&gt;right-&gt;code, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">            generateHuffmanCode(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*传入权重表构建Huffman树*/</span></span><br><span class="line"><span class="function">pNode <span class="title">buildHuffmanTree</span><span class="params">(<span class="keyword">int</span> times[])</span> </span>&#123;</span><br><span class="line">    pNode nodelist[FOREST_SIZE] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">    pNode root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">startstamp</span> =</span> startTimestamp();</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">/*创建森林表*/</span></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; LIST_SIZE; ++index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (times[index] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*将所有节点逐个放入森林表*/</span></span><br><span class="line">            addNodeToList(nodelist, FOREST_SIZE, createDataNode(index, times[index]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*构建Huffman树*/</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pNode left = popMinNodeFromList(nodelist, FOREST_SIZE);</span><br><span class="line">        pNode right = popMinNodeFromList(nodelist, FOREST_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/*当森林中只剩下一颗树节点的时候表示整个Huffman树构建完成*/</span></span><br><span class="line">            root = left;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pNode node = createBlankNode(left-&gt;weight + right-&gt;weight);</span><br><span class="line">            node-&gt;left = left;</span><br><span class="line">            node-&gt;right = right;</span><br><span class="line">            <span class="comment">/*每次从森林表中取出两个最小的节点，并创建新节点重新放入森林表*/</span></span><br><span class="line">            addNodeToList(nodelist, FOREST_SIZE, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    generateHuffmanCode(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;       bulid huffman tree : %lf msc\n&quot;</span>, endTimestamp(startstamp));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在Huffman树中前进一步*/</span></span><br><span class="line"><span class="function">pNode <span class="title">setpHuffmanTree</span><span class="params">(pNode root, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (flag) &#123;</span><br><span class="line">    <span class="keyword">case</span> NODE_FLAG_LEFT:</span><br><span class="line">        <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">    <span class="keyword">case</span> NODE_FLAG_RIGHT:</span><br><span class="line">        <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通过后序遍历的方式销毁Huffman树*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroyHuffmanTree</span><span class="params">(pNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        destroyHuffmanTree(root-&gt;left);</span><br><span class="line">        destroyHuffmanTree(root-&gt;right);</span><br><span class="line">        <span class="built_in">free</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从文件构建Huffman树*/</span></span><br><span class="line"><span class="function">pNode <span class="title">buildHuffmanTreeFromFile</span><span class="params">(FILE* input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times[LIST_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    Byte byte;</span><br><span class="line">    <span class="keyword">while</span> (fread(&amp;byte, <span class="keyword">sizeof</span>(byte), <span class="number">1</span>, input) == <span class="number">1</span>) &#123;</span><br><span class="line">        ++times[byte];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildHuffmanTree(times);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算Huffman树的权重总值*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countHuffmanTreeWeightTotal</span><span class="params">(pNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="comment">/*只获取有效字符节点*/</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;type == NODE_TYPE_DATA) &#123;</span><br><span class="line">            total = root-&gt;weight;</span><br><span class="line">        &#125;</span><br><span class="line">        total += countHuffmanTreeWeightTotal(root-&gt;left);</span><br><span class="line">        total += countHuffmanTreeWeightTotal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通过递归遍历将Huffman树转换成Huffman表*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertTreeToList</span><span class="params">(pNode root, pNode nodelist[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="comment">/*只获取有效字符节点*/</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;type == NODE_TYPE_DATA) &#123;</span><br><span class="line">            nodelist[root-&gt;data] = root;</span><br><span class="line">        &#125;</span><br><span class="line">        convertTreeToList(root-&gt;left, nodelist);</span><br><span class="line">        convertTreeToList(root-&gt;right, nodelist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清理Huffman表中的空指针，并返回实际的表元素数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trimNodeList</span><span class="params">(pNode nodelist[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; size; ++index) &#123;</span><br><span class="line">        pNode node = nodelist[index];</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            nodelist[count++] = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对文件数据进行Huffman编码*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">encodeFileData</span><span class="params">(pNode root, FILE* input, FILE* output)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        Byte byte;</span><br><span class="line">        <span class="keyword">int</span> buffer = <span class="number">0</span>;</span><br><span class="line">        pNode nodelist[LIST_SIZE] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">        <span class="comment">/*将Huffman树转换成Huffman表*/</span></span><br><span class="line">        convertTreeToList(root, nodelist);</span><br><span class="line">        <span class="keyword">while</span> (fread(&amp;byte, <span class="keyword">sizeof</span>(byte), <span class="number">1</span>, input) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span>* cursor = nodelist[byte]-&gt;code;</span><br><span class="line">            <span class="keyword">while</span> (*cursor) &#123;</span><br><span class="line">                buffer &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (*cursor == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    buffer |= <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    buffer |= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++count;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">8</span>) &#123;</span><br><span class="line">                    Byte byte = (Byte)buffer;</span><br><span class="line">                    fwrite(&amp;byte, <span class="keyword">sizeof</span>(byte), <span class="number">1</span>, output);</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    buffer = <span class="number">0</span>;</span><br><span class="line">                    ++total;</span><br><span class="line">                &#125;</span><br><span class="line">                ++cursor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer &lt;&lt;= (<span class="number">8</span> - count);</span><br><span class="line">            <span class="keyword">char</span> byte = (<span class="keyword">char</span>)buffer;</span><br><span class="line">            fwrite(&amp;byte, <span class="number">1</span>, <span class="number">1</span>, output);</span><br><span class="line">            ++total;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对文件数据进行Huffman解码*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decodeFileData</span><span class="params">(pNode root, FILE* input, FILE* output, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        Byte byte;</span><br><span class="line">        pNode cursor = root;</span><br><span class="line">        <span class="keyword">while</span> (fread(&amp;byte, <span class="keyword">sizeof</span>(byte), <span class="number">1</span>, input) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> buffer = byte;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; <span class="number">8</span>; ++index) &#123;</span><br><span class="line">                buffer &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!cursor-&gt;left || !cursor-&gt;right) &#123;</span><br><span class="line">                    Byte data = (Byte)cursor-&gt;data;</span><br><span class="line">                    fwrite(&amp;data, <span class="keyword">sizeof</span>(data), <span class="number">1</span>, output);</span><br><span class="line">                    <span class="keyword">if</span> (--count == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cursor = root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (buffer &amp; ~<span class="number">0xff</span>) &#123;</span><br><span class="line">                    cursor = setpHuffmanTree(cursor, NODE_FLAG_RIGHT);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cursor = setpHuffmanTree(cursor, NODE_FLAG_LEFT);</span><br><span class="line">                &#125;</span><br><span class="line">                buffer &amp;= <span class="number">0xff</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*检测是否是可显示字符*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canShowChar</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ch &gt; <span class="number">32</span> &amp;&amp; ch &lt; <span class="number">127</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通过递归遍历方式打印Huffman树*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outputHuffmanTree</span><span class="params">(FILE* output, pNode root, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">char</span> content[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* flagname[] = &#123; <span class="string">&quot;ROOT&quot;</span>, <span class="string">&quot;LEFT&quot;</span>, <span class="string">&quot;RIGHT&quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> offset = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(root-&gt;code) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; offset; ++index) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;code[index] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(output, <span class="string">&quot; │ &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(output, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (root-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> NODE_TYPE_DATA:</span><br><span class="line">            <span class="built_in">sprintf</span>(content, <span class="string">&quot;&gt; %-6s #%-4d 0x%02X : &#x27;%c&#x27;&quot;</span>, flagname[flag], root-&gt;weight, root-&gt;data, canShowChar((<span class="keyword">char</span>)root-&gt;data) ? root-&gt;data : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NODE_TYPE_BLANK:</span><br><span class="line">            <span class="built_in">sprintf</span>(content, <span class="string">&quot;[+] %-6s #%-4d&quot;</span>, flagname[flag], root-&gt;weight);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">case</span> NODE_FLAG_ROOT:</span><br><span class="line">            <span class="built_in">fprintf</span>(output, <span class="string">&quot;%s&quot;</span>, content);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NODE_FLAG_LEFT:</span><br><span class="line">            <span class="built_in">fprintf</span>(output, <span class="string">&quot; ├─%s&quot;</span>, content);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NODE_FLAG_RIGHT:</span><br><span class="line">            <span class="built_in">fprintf</span>(output, <span class="string">&quot; └─%s&quot;</span>, content);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;type == NODE_TYPE_DATA) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(output, <span class="string">&quot; CODE : %s\n&quot;</span>, root-&gt;code);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(output, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        outputHuffmanTree(output, root-&gt;left, NODE_FLAG_LEFT);</span><br><span class="line">        outputHuffmanTree(output, root-&gt;right, NODE_FLAG_RIGHT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印Huffman树*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHuffmanTree</span><span class="params">(FILE* output, pNode root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(output, <span class="string">&quot;    *******************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(output, <span class="string">&quot;       Print Huffman Tree\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(output, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    outputHuffmanTree(output, root, NODE_FLAG_ROOT);</span><br><span class="line">    <span class="built_in">fprintf</span>(output, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将Huffman表中的数据输出成编码和权重统计表*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHuffmanList</span><span class="params">(FILE* output, pNode root)</span> </span>&#123;</span><br><span class="line">    pNode nodelist[LIST_SIZE] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> listcount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*将Huffman树转换成Huffman表*/</span></span><br><span class="line">    convertTreeToList(root, nodelist);</span><br><span class="line">    listcount = trimNodeList(nodelist, LIST_SIZE);</span><br><span class="line">    <span class="built_in">fprintf</span>(output, <span class="string">&quot;    *******************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(output, <span class="string">&quot;        # Print Huffman Code List #\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(output, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(output, <span class="string">&quot;                       Total : %d\n&quot;</span>, listcount);</span><br><span class="line">    <span class="built_in">fprintf</span>(output, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(output, <span class="string">&quot;     %-7s%-10s%-10s%s\n&quot;</span>, <span class="string">&quot;ASCII&quot;</span>, <span class="string">&quot;Char&quot;</span>, <span class="string">&quot;Weight&quot;</span>, <span class="string">&quot;Code&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; listcount; ++index) &#123;</span><br><span class="line">        pNode node = nodelist[index];</span><br><span class="line">        Byte ch = (Byte)node-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> (canShowChar((<span class="keyword">char</span>)ch)) &#123;</span><br><span class="line">            <span class="comment">/*可显示字符的输出*/</span></span><br><span class="line">            <span class="built_in">fprintf</span>(output, <span class="string">&quot;     %-7d%-10c%-10d%s\n&quot;</span>, ch, ch, node-&gt;weight, node-&gt;code);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*不可显示字符的输出*/</span></span><br><span class="line">            <span class="built_in">fprintf</span>(output, <span class="string">&quot;     %-7d%-10s%-10d%s\n&quot;</span>, ch, <span class="string">&quot;NOShow&quot;</span>, node-&gt;weight, node-&gt;code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*统计输入的字符权重*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contUserInputTimes</span><span class="params">(<span class="keyword">int</span> times[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index, count;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    *******************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        # Input data to test #\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        Number of input nodes : &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        Enter the letters and weights for each node : \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; count; ++index) &#123;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> weight = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        Char   : &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        Weight : &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;weight);</span><br><span class="line">        times[(<span class="keyword">int</span>)str[<span class="number">0</span>]] = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输入数据构建Huffman树选项*/</span></span><br><span class="line"><span class="function">pNode <span class="title">inputDataToBuildHuffmanTreeOption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times[LIST_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    contUserInputTimes(times);</span><br><span class="line">    <span class="keyword">return</span> buildHuffmanTree(times);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取输入选项*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inputOption</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> opt;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;opt) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (opt &gt;= begin &amp;&amp; opt &lt;= end) &#123;</span><br><span class="line">                <span class="keyword">return</span> opt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;       error : The input range should be between %d and %d.\n&quot;</span>, begin, end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       error : Please enter integer type.\n&quot;</span>);</span><br><span class="line">            <span class="comment">/*清空缓冲区*/</span></span><br><span class="line">            setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*检测文件类型*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFileType</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> filename[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type = FILE_TYPE_NULL;</span><br><span class="line">    FILE* input = fopen(filename, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (input) &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        type = FILE_TYPE_ENCODE;</span><br><span class="line">        <span class="keyword">if</span> (fread(buffer, <span class="number">2</span>, <span class="number">1</span>, input) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[<span class="number">0</span>] == FILE_HEADER_FLAG[<span class="number">0</span>] &amp;&amp; buffer[<span class="number">1</span>] == FILE_HEADER_FLAG[<span class="number">1</span>]) &#123;</span><br><span class="line">                type = FILE_TYPE_DECODE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写入文件头信息（文件头含文件头标识和字符权重集）*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeFileHeader</span><span class="params">(pNode root, FILE* output)</span> </span>&#123;</span><br><span class="line">    pNode nodelist[LIST_SIZE] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">    Byte total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">/*写入文件头标识*/</span></span><br><span class="line">    fwrite(FILE_HEADER_FLAG, <span class="number">2</span>, <span class="number">1</span>, output);</span><br><span class="line">    convertTreeToList(root, nodelist);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 为节省空间字符集总量存储为1个字节</span></span><br><span class="line"><span class="comment">    * 总量1用0表示，总量256用255表示</span></span><br><span class="line"><span class="comment">    * 所以总量 - 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    total = (Byte)(trimNodeList(nodelist, LIST_SIZE) - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*写入字符集总数*/</span></span><br><span class="line">    fwrite(&amp;total, <span class="keyword">sizeof</span>(total), <span class="number">1</span>, output);</span><br><span class="line">    <span class="comment">/*写入每个字符以及权重*/</span></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt;= total; ++index) &#123;</span><br><span class="line">        pNode node = nodelist[index];</span><br><span class="line">        Byte byte = (Byte)node-&gt;data;</span><br><span class="line">        fwrite(&amp;byte, <span class="keyword">sizeof</span>(byte), <span class="number">1</span>, output);</span><br><span class="line">        fwrite(&amp;node-&gt;weight, <span class="keyword">sizeof</span>(node-&gt;weight), <span class="number">1</span>, output);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回写入的文件头总字节数*/</span></span><br><span class="line">    <span class="keyword">return</span> (total * <span class="number">5</span> + <span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读取文件头信息（读取字符权重集）*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFileHeader</span><span class="params">(FILE* input, <span class="keyword">int</span> times[])</span> </span>&#123;</span><br><span class="line">    Byte total;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">/*跳过文件头*/</span></span><br><span class="line">    fseek(input, <span class="number">2</span>, SEEK_CUR);</span><br><span class="line">    fread(&amp;total, <span class="keyword">sizeof</span>(total), <span class="number">1</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt;= total; ++index) &#123;</span><br><span class="line">        Byte byte;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">        fread(&amp;byte, <span class="keyword">sizeof</span>(byte), <span class="number">1</span>, input);</span><br><span class="line">        fread(&amp;weight, <span class="keyword">sizeof</span>(weight), <span class="number">1</span>, input);</span><br><span class="line">        times[byte] = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对文件进行编码*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toEncode</span><span class="params">(pNode root, FILE* input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> filename[PATH_MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FILE* output = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    *******************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        # Write File #\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;       write file name : &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, filename);</span><br><span class="line">    output = fopen(filename, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (output) &#123;</span><br><span class="line">        <span class="keyword">int</span> rawsize = countHuffmanTreeWeightTotal(root);</span><br><span class="line">        <span class="keyword">int</span> header_size = writeFileHeader(root, output);</span><br><span class="line">        <span class="keyword">if</span> (input) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">startstamp</span> =</span> startTimestamp();</span><br><span class="line">            <span class="keyword">int</span> compressedsize = encodeFileData(root, input, output);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       Elapsed Time      : %lf msc\n&quot;</span>, endTimestamp(startstamp));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       Character Set     : %d Bytes\n&quot;</span>, header_size);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       Compressed Data   : %d Bytes\n&quot;</span>, compressedsize);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       Raw Data          : %d Bytes\n&quot;</span>, rawsize);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       Compression Ratio : %.2lf%%\n&quot;</span>, (compressedsize / (<span class="keyword">double</span>)rawsize) * <span class="number">100</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       Execute successfully.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       error : Failed to read file.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(output);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       error : Failed to write file.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对文件进行解码*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toDecode</span><span class="params">(pNode root, FILE* input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> filename[PATH_MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FILE* output = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    *******************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        # Write File #\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;       write file name : &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, filename);</span><br><span class="line">    output = fopen(filename, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (output) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">startstamp</span> =</span> startTimestamp();</span><br><span class="line">        decodeFileData(root, input, output, countHuffmanTreeWeightTotal(root));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       Elapsed Time      : %lf msc\n&quot;</span>, endTimestamp(startstamp));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       Execute successfully.\n&quot;</span>);</span><br><span class="line">        fclose(output);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       error : Failed to write file.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*文件编码选项*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encodeFileOption</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> filename[])</span> </span>&#123;</span><br><span class="line">    FILE* input = fopen(filename, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (input) &#123;</span><br><span class="line">        pNode root = buildHuffmanTreeFromFile(input);</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> option;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;    *******************************\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;        # Encode File #\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;       1 &gt; Print Huffman Tree\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;       2 &gt; Print Huffman Code List\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;       3 &gt; Encode File\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;       0 &gt; Back\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                option = inputOption(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span> (option == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    printHuffmanTree(<span class="built_in">stdout</span>, root);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    printHuffmanList(<span class="built_in">stdout</span>, root);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="comment">/*重置文件指针到文件头*/</span></span><br><span class="line">                    fseek(input, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">                    toEncode(root, input);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">            destroyHuffmanTree(root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       error : Failed to build Huffman tree.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(input);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       error : Failed to read file.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*文件解码选项*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decodeFileOption</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> filename[])</span> </span>&#123;</span><br><span class="line">    FILE* input = fopen(filename, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (input) &#123;</span><br><span class="line">        <span class="keyword">int</span> tell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> times[LIST_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        readFileHeader(input, times);</span><br><span class="line">        <span class="comment">/*记录文件数据区位置*/</span></span><br><span class="line">        tell = (<span class="keyword">int</span>)ftell(input);</span><br><span class="line">        pNode root = buildHuffmanTree(times);</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> option;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;    *******************************\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;        # Decode File #\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;       1 &gt; Print Huffman Tree\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;       2 &gt; Print Huffman Code List\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;       3 &gt; Decode File\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;       0 &gt; Back\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                option = inputOption(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span> (option == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    printHuffmanTree(<span class="built_in">stdout</span>, root);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    printHuffmanList(<span class="built_in">stdout</span>, root);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="comment">/*将文件指针定位到数据区*/</span></span><br><span class="line">                    fseek(input, tell, SEEK_SET);</span><br><span class="line">                    toDecode(root, input);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">            destroyHuffmanTree(root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       error : Failed to build Huffman tree.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(input);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       error : Failed to read file.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读文件选项*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFileOption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> filename[PATH_MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    *******************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        # Read File #\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;       input file name : &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, filename);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (getFileType(filename)) &#123;</span><br><span class="line">    <span class="keyword">case</span> FILE_TYPE_ENCODE:</span><br><span class="line">        encodeFileOption(filename);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FILE_TYPE_DECODE:</span><br><span class="line">        decodeFileOption(filename);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       error : Failed to read file.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试选项*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputDataToTestOption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pNode root = inputDataToBuildHuffmanTreeOption();</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> option;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    *******************************\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       1 &gt; Print Huffman Tree\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       2 &gt; Print Huffman Code List\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       0 &gt; Back\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            option = inputOption(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (option == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                printHuffmanTree(<span class="built_in">stdout</span>, root);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                printHuffmanList(<span class="built_in">stdout</span>, root);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">        destroyHuffmanTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Huffman功能演示*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">huffmanDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> option;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    *******************************\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        # Huffman Tree Demo #\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       1 &gt; Read file\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       2 &gt; Input data to test\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       0 &gt; Quit\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        option = inputOption(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (option == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            readFileOption();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            inputDataToTestOption();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    huffmanDemo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>huffman</tag>
      </tags>
  </entry>
</search>
